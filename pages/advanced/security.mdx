# Security Features

Comprehensive guide to Lokus security features, best practices, and threat mitigation strategies.

**Version:** 1.3.1 | **Status:** Production Ready

## What's New in v1.3

**OAuth 2.0 + PKCE**
Production-ready OAuth 2.0 implementation with PKCE (Proof Key for Code Exchange) for enhanced security. Prevents authorization code interception attacks and eliminates need for client secrets in native apps.

**Platform-Native Token Storage**
Secure credential storage using macOS Keychain and Windows Credential Manager. Tokens encrypted at rest with OS-level security.

**Hybrid Redirect Flow**
Smart redirect handling using deep links with localhost fallback. Seamless OAuth experience across platforms.

**Automatic Token Refresh**
Background token renewal without user intervention. Maintains session continuity with exponential backoff retry logic.

## Security Architecture

Lokus implements defense-in-depth security:

1. **File System Sandboxing** - Restricted file access
2. **Plugin Permissions** - Granular permission system
3. **Secure Storage** - Platform-native credential storage
4. **Input Validation** - XSS and injection prevention
5. **Network Security** - HTTPS enforcement, CORS protection
6. **OAuth Security** - Secure authentication flows

## File System Security

### Path Validation

All file operations validate paths to prevent directory traversal attacks:

```typescript
function isValidPath(path: string): boolean {
  // Prevent directory traversal
  if (path.includes('..')) {
    return false;
  }

  // Ensure path is within workspace
  const normalizedPath = normalizePath(path);
  const workspacePath = getWorkspacePath();

  return normalizedPath.startsWith(workspacePath);
}
```

**Protected Against:**
- `../../../etc/passwd` - Directory traversal
- `file:///etc/passwd` - Absolute paths outside workspace
- Symbolic link attacks
- Race conditions (TOCTOU)

---

### File Type Validation

```typescript
const ALLOWED_FILE_TYPES = [
  '.md', '.txt', '.json',
  '.js', '.ts', '.jsx', '.tsx',
  '.html', '.css', '.yaml', '.toml'
];

function validateFileType(path: string): boolean {
  const ext = path.toLowerCase().match(/\.[^.]+$/)?.[0];
  return ALLOWED_FILE_TYPES.includes(ext);
}
```

**Configure allowed types:**
```json
{
  "security": {
    "allowedFileTypes": [".md", ".txt", ".json"],
    "validateFileTypes": true
  }
}
```

---

### File Size Limits

```json
{
  "security": {
    "maxFileSize": 10485760,
    "maxUploadSize": 5242880
  }
}
```

**Default limits:**
- Max file size: 10MB
- Max upload size: 5MB
- Max workspace size: Unlimited (user discretion)

---

## Plugin Security

### Permission System

Plugins must declare required permissions:

```json
{
  "name": "example-plugin",
  "permissions": [
    "read:files",
    "write:files",
    "network:https"
  ]
}
```

**Available Permissions:**
- `read:files` - Read workspace files
- `write:files` - Write to workspace files
- `read:workspace` - Read workspace metadata
- `write:workspace` - Modify workspace
- `execute:commands` - Execute system commands
- `network:http` - HTTP requests
- `network:https` - HTTPS requests
- `ui:editor` - Modify editor
- `ui:sidebar` - Add UI panels
- `storage:local` - Local storage access
- `clipboard:read` - Read clipboard
- `clipboard:write` - Write clipboard

---

### Permission Enforcement

```typescript
class PluginAPI {
  async readFile(path: string): Promise<string> {
    // Check permission
    if (!this.hasPermission('read:files')) {
      throw new Error('Plugin lacks read:files permission');
    }

    // Validate path
    if (!isValidPath(path)) {
      throw new Error('Invalid file path');
    }

    // Perform operation
    return await invoke('read_file_content', { path });
  }
}
```

---

### Plugin Sandboxing

```json
{
  "security": {
    "sandboxPlugins": true,
    "pluginTimeout": 30000,
    "maxPluginMemory": 104857600
  }
}
```

**Sandbox Features:**
- Isolated execution context
- Memory limits (100MB default)
- Timeout protection (30s default)
- No access to Node.js APIs
- No eval() or Function() constructor

---

### Plugin Validation

```typescript
async function validatePlugin(manifest: PluginManifest): Promise<ValidationResult> {
  const errors: ValidationError[] = [];

  // Validate name
  if (!/^[a-zA-Z0-9-_]+$/.test(manifest.name)) {
    errors.push({
      field: 'name',
      message: 'Invalid plugin name'
    });
  }

  // Validate version
  if (!semver.valid(manifest.version)) {
    errors.push({
      field: 'version',
      message: 'Invalid semantic version'
    });
  }

  // Validate permissions
  for (const permission of manifest.permissions) {
    if (!VALID_PERMISSIONS.includes(permission)) {
      errors.push({
        field: 'permissions',
        message: `Invalid permission: ${permission}`
      });
    }
  }

  return {
    valid: errors.length === 0,
    errors,
    warnings: []
  };
}
```

---

## Authentication Security

### OAuth 2.0 + PKCE Implementation

Lokus v1.3 implements OAuth 2.0 with PKCE (RFC 7636) for secure authentication with external services like Gmail, GitHub, and custom OAuth providers.

#### Why PKCE?

**Security Benefits:**
- Prevents authorization code interception attacks
- No client secret needed (safer for native apps)
- Mitigates CSRF attacks
- Protects against malicious apps on same device
- Required by OAuth 2.1 spec for all clients

**Traditional OAuth vs PKCE:**

| Feature | Traditional OAuth 2.0 | OAuth 2.0 + PKCE |
|---------|----------------------|------------------|
| Client Secret Required | Yes | No |
| Code Interception Risk | High | Low |
| Native App Security | Moderate | High |
| CSRF Protection | State parameter only | State + Code verifier |
| Complexity | Lower | Slightly higher |

#### Complete PKCE Flow

```typescript
// 1. Generate code verifier and challenge
import { randomBytes, createHash } from 'crypto'

interface PKCEChallenge {
  codeVerifier: string
  codeChallenge: string
  codeChallengeMethod: 'S256'
}

function generatePKCEChallenge(): PKCEChallenge {
  // Generate cryptographically secure random string (43-128 chars)
  const codeVerifier = randomBytes(32)
    .toString('base64url') // URL-safe base64
    .slice(0, 128) // Max 128 characters

  // Create SHA-256 hash of verifier
  const hash = createHash('sha256')
    .update(codeVerifier)
    .digest('base64url')

  return {
    codeVerifier,
    codeChallenge: hash,
    codeChallengeMethod: 'S256'
  }
}

// 2. Generate CSRF protection state
function generateState(): string {
  return randomBytes(32).toString('hex') // 64 hex characters
}
```

```typescript
// 3. Complete OAuth flow manager
class OAuth2PKCEManager {
  private codeVerifier: string | null = null
  private state: string | null = null

  /**
   * Initiate OAuth flow
   * Returns authorization URL to open in browser
   */
  async initiateFlow(config: OAuthConfig): Promise<string> {
    // Generate PKCE challenge
    const pkce = generatePKCEChallenge()
    this.codeVerifier = pkce.codeVerifier

    // Generate CSRF protection state
    this.state = generateState()

    // Store in secure temporary storage
    await this.storeFlowState({
      codeVerifier: pkce.codeVerifier,
      state: this.state,
      timestamp: Date.now(),
      provider: config.provider
    })

    // Build authorization URL
    const params = new URLSearchParams({
      client_id: config.clientId,
      redirect_uri: config.redirectUri,
      response_type: 'code',
      scope: config.scopes.join(' '),
      state: this.state,
      code_challenge: pkce.codeChallenge,
      code_challenge_method: pkce.codeChallengeMethod,
      // Optional: force reauth, select account, etc.
      prompt: config.prompt || 'consent',
      access_type: 'offline' // Request refresh token
    })

    return `${config.authorizationEndpoint}?${params}`
  }

  /**
   * Handle OAuth callback
   * Validates state and exchanges code for tokens
   */
  async handleCallback(
    code: string,
    state: string,
    config: OAuthConfig
  ): Promise<TokenResponse> {
    // 1. Retrieve stored flow state
    const flowState = await this.getFlowState()
    if (!flowState) {
      throw new OAuthError('No OAuth flow in progress', 'INVALID_FLOW')
    }

    // 2. Validate state (CSRF protection)
    if (state !== flowState.state) {
      throw new OAuthError('Invalid OAuth state parameter', 'INVALID_STATE')
    }

    // 3. Check flow expiry (15 minutes)
    const now = Date.now()
    const flowAge = now - flowState.timestamp
    if (flowAge > 15 * 60 * 1000) {
      throw new OAuthError('OAuth flow expired', 'FLOW_EXPIRED')
    }

    // 4. Clear flow state
    await this.clearFlowState()

    // 5. Exchange authorization code for tokens
    try {
      const tokens = await this.exchangeCode(
        code,
        flowState.codeVerifier,
        config
      )

      // 6. Store tokens securely
      await this.storeTokensSecurely(config.provider, tokens)

      return tokens
    } catch (error) {
      throw new OAuthError(
        `Token exchange failed: ${error.message}`,
        'TOKEN_EXCHANGE_FAILED',
        error
      )
    }
  }

  /**
   * Exchange authorization code for tokens
   * Uses code verifier to prove authenticity
   */
  private async exchangeCode(
    code: string,
    codeVerifier: string,
    config: OAuthConfig
  ): Promise<TokenResponse> {
    const params = new URLSearchParams({
      client_id: config.clientId,
      code,
      code_verifier: codeVerifier,
      grant_type: 'authorization_code',
      redirect_uri: config.redirectUri
    })

    // Note: No client_secret needed with PKCE!
    const response = await fetch(config.tokenEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Accept': 'application/json'
      },
      body: params.toString()
    })

    if (!response.ok) {
      const error = await response.json()
      throw new Error(error.error_description || error.error)
    }

    const tokens: TokenResponse = await response.json()

    return {
      accessToken: tokens.access_token,
      refreshToken: tokens.refresh_token,
      expiresIn: tokens.expires_in,
      tokenType: tokens.token_type,
      scope: tokens.scope,
      expiresAt: Date.now() + (tokens.expires_in * 1000)
    }
  }

  /**
   * Store flow state in secure temporary storage
   */
  private async storeFlowState(state: FlowState): Promise<void> {
    // Use encrypted temporary storage (cleared after flow completes)
    await invoke('store_temp_data', {
      key: 'oauth_flow_state',
      data: JSON.stringify(state),
      ttl: 900 // 15 minutes
    })
  }

  private async getFlowState(): Promise<FlowState | null> {
    const data = await invoke<string | null>('get_temp_data', {
      key: 'oauth_flow_state'
    })
    return data ? JSON.parse(data) : null
  }

  private async clearFlowState(): Promise<void> {
    await invoke('clear_temp_data', { key: 'oauth_flow_state' })
  }
}

// TypeScript interfaces
interface OAuthConfig {
  provider: string
  clientId: string
  redirectUri: string
  authorizationEndpoint: string
  tokenEndpoint: string
  scopes: string[]
  prompt?: 'none' | 'consent' | 'select_account'
}

interface TokenResponse {
  accessToken: string
  refreshToken?: string
  expiresIn: number
  tokenType: string
  scope?: string
  expiresAt: number
}

interface FlowState {
  codeVerifier: string
  state: string
  timestamp: number
  provider: string
}

class OAuthError extends Error {
  constructor(
    message: string,
    public code: string,
    public cause?: Error
  ) {
    super(message)
    this.name = 'OAuthError'
  }
}
```

#### Hybrid Redirect Flow

Lokus uses a hybrid redirect approach for maximum compatibility:

```typescript
class HybridRedirectHandler {
  /**
   * Try deep link first, fallback to localhost
   */
  async handleRedirect(authUrl: string): Promise<TokenResponse> {
    // 1. Start localhost server as fallback
    const localPort = await this.startLocalServer()
    const localRedirectUri = `http://127.0.0.1:${localPort}/oauth/callback`

    // 2. Try deep link redirect
    const deepLinkUri = 'lokus://oauth/callback'

    // Check if deep link is registered
    const hasDeepLink = await this.checkDeepLinkRegistration()

    // 3. Update auth URL with appropriate redirect
    const redirectUri = hasDeepLink ? deepLinkUri : localRedirectUri
    const finalAuthUrl = authUrl.replace(
      /redirect_uri=[^&]+/,
      `redirect_uri=${encodeURIComponent(redirectUri)}`
    )

    // 4. Open in browser
    await open(finalAuthUrl)

    // 5. Wait for callback (either deep link or localhost)
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        this.stopLocalServer()
        reject(new Error('OAuth timeout'))
      }, 5 * 60 * 1000) // 5 minutes

      // Handle deep link callback
      if (hasDeepLink) {
        this.onDeepLink((code, state) => {
          clearTimeout(timeout)
          this.stopLocalServer()
          resolve(this.completeFlow(code, state))
        })
      }

      // Local server handles localhost callback
      // (automatically resolves promise)
    })
  }

  private async startLocalServer(): Promise<number> {
    const server = express()
    const port = await getAvailablePort(8000, 8100)

    server.get('/oauth/callback', async (req, res) => {
      const { code, state, error, error_description } = req.query

      if (error) {
        res.send(`<h1>Authorization failed</h1><p>${error_description}</p>`)
        this.handleError(error as string, error_description as string)
        return
      }

      // Handle successful callback
      try {
        await this.completeFlow(code as string, state as string)
        res.send('<h1>Success!</h1><p>You can close this window.</p>')
      } catch (err) {
        res.send(`<h1>Error</h1><p>${err.message}</p>`)
      }
    })

    await server.listen(port)
    return port
  }
}
```

#### Rust Backend Implementation

```rust
// src-tauri/src/oauth.rs
use base64::{engine::general_purpose, Engine};
use rand::Rng;
use sha2::{Digest, Sha256};
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PKCEChallenge {
    pub code_verifier: String,
    pub code_challenge: String,
    pub code_challenge_method: String,
}

/// Generate PKCE challenge pair
pub fn generate_pkce_challenge() -> PKCEChallenge {
    // Generate 32 random bytes
    let mut rng = rand::thread_rng();
    let random_bytes: Vec<u8> = (0..32).map(|_| rng.gen()).collect();

    // Base64URL encode (code verifier)
    let code_verifier = general_purpose::URL_SAFE_NO_PAD
        .encode(&random_bytes);

    // SHA-256 hash the verifier
    let mut hasher = Sha256::new();
    hasher.update(code_verifier.as_bytes());
    let hash_result = hasher.finalize();

    // Base64URL encode the hash (code challenge)
    let code_challenge = general_purpose::URL_SAFE_NO_PAD
        .encode(&hash_result);

    PKCEChallenge {
        code_verifier,
        code_challenge,
        code_challenge_method: "S256".to_string(),
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OAuthTokens {
    pub access_token: String,
    pub refresh_token: Option<String>,
    pub expires_in: u64,
    pub token_type: String,
    pub scope: Option<String>,
}

/// Exchange authorization code for tokens
pub async fn exchange_code(
    code: &str,
    code_verifier: &str,
    config: &OAuthConfig,
) -> Result<OAuthTokens, OAuthError> {
    let client = reqwest::Client::new();

    let params = [
        ("client_id", config.client_id.as_str()),
        ("code", code),
        ("code_verifier", code_verifier),
        ("grant_type", "authorization_code"),
        ("redirect_uri", config.redirect_uri.as_str()),
    ];

    let response = client
        .post(&config.token_endpoint)
        .form(&params)
        .send()
        .await?;

    if !response.status().is_success() {
        let error_body = response.text().await?;
        return Err(OAuthError::TokenExchangeFailed(error_body));
    }

    let tokens: OAuthTokens = response.json().await?;
    Ok(tokens)
}

#[derive(Debug, Serialize, Deserialize)]
pub struct OAuthConfig {
    pub client_id: String,
    pub redirect_uri: String,
    pub authorization_endpoint: String,
    pub token_endpoint: String,
    pub scopes: Vec<String>,
}

#[derive(Debug, thiserror::Error)]
pub enum OAuthError {
    #[error("Token exchange failed: {0}")]
    TokenExchangeFailed(String),

    #[error("Invalid state parameter")]
    InvalidState,

    #[error("Flow expired")]
    FlowExpired,

    #[error("Network error: {0}")]
    NetworkError(#[from] reqwest::Error),
}
```

---

### Secure Token Storage

**Platform-specific secure storage:**

**macOS - Keychain:**
```rust
use keyring::Keyring;

fn store_token(service: &str, account: &str, token: &str) -> Result<(), String> {
    let keyring = Keyring::new(service, account);
    keyring.set_password(token)
        .map_err(|e| e.to_string())
}

fn retrieve_token(service: &str, account: &str) -> Result<String, String> {
    let keyring = Keyring::new(service, account);
    keyring.get_password()
        .map_err(|e| e.to_string())
}
```

**Windows - Credential Manager:**
```rust
use windows::Security::Credentials::PasswordVault;

fn store_token_windows(resource: &str, username: &str, password: &str) {
    let vault = PasswordVault::new().unwrap();
    let credential = PasswordCredential::CreatePasswordCredential(
        resource,
        username,
        password
    ).unwrap();
    vault.Add(&credential).unwrap();
}
```

**Never store tokens in:**
- Plain text files
- Local storage
- Session storage
- Configuration files
- Version control

---

### Automatic Token Refresh

Production-ready token manager with automatic refresh, retry logic, and token rotation:

```typescript
class TokenManager {
  private accessToken: string | null = null
  private refreshToken: string | null = null
  private expiresAt: number = 0
  private refreshPromise: Promise<void> | null = null
  private config: OAuthConfig

  constructor(config: OAuthConfig) {
    this.config = config
    this.loadTokens()
  }

  /**
   * Get valid access token (refreshes if expired)
   */
  async getAccessToken(): Promise<string> {
    // Check if token exists
    if (!this.accessToken) {
      throw new Error('Not authenticated')
    }

    // Check if token is expired (with 5 minute buffer)
    const buffer = 5 * 60 * 1000 // 5 minutes
    if (Date.now() >= this.expiresAt - buffer) {
      await this.refreshAccessToken()
    }

    return this.accessToken
  }

  /**
   * Refresh access token using refresh token
   * Thread-safe: multiple calls wait for single refresh
   */
  async refreshAccessToken(): Promise<void> {
    // If refresh is already in progress, wait for it
    if (this.refreshPromise) {
      return this.refreshPromise
    }

    // Start refresh
    this.refreshPromise = this._performRefresh()

    try {
      await this.refreshPromise
    } finally {
      this.refreshPromise = null
    }
  }

  private async _performRefresh(): Promise<void> {
    if (!this.refreshToken) {
      throw new Error('No refresh token available')
    }

    const maxRetries = 3
    let lastError: Error | null = null

    // Exponential backoff retry
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        const newTokens = await this._exchangeRefreshToken()

        // Update tokens
        this.accessToken = newTokens.accessToken
        if (newTokens.refreshToken) {
          // Some providers rotate refresh tokens
          this.refreshToken = newTokens.refreshToken
        }
        this.expiresAt = newTokens.expiresAt

        // Store new tokens securely
        await this.storeTokens({
          accessToken: this.accessToken,
          refreshToken: this.refreshToken,
          expiresAt: this.expiresAt
        })

        return // Success!
      } catch (error) {
        lastError = error

        // Don't retry on certain errors
        if (this.isNonRetryableError(error)) {
          throw error
        }

        // Exponential backoff: 1s, 2s, 4s
        const delay = Math.pow(2, attempt) * 1000
        await this.sleep(delay)
      }
    }

    // All retries failed
    throw new Error(`Token refresh failed after ${maxRetries} attempts: ${lastError}`)
  }

  private async _exchangeRefreshToken(): Promise<TokenResponse> {
    const params = new URLSearchParams({
      client_id: this.config.clientId,
      refresh_token: this.refreshToken!,
      grant_type: 'refresh_token'
    })

    const response = await fetch(this.config.tokenEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Accept': 'application/json'
      },
      body: params.toString()
    })

    if (!response.ok) {
      const error = await response.json()
      throw new TokenRefreshError(
        error.error_description || error.error,
        response.status,
        error.error
      )
    }

    const tokens = await response.json()

    return {
      accessToken: tokens.access_token,
      refreshToken: tokens.refresh_token, // May be null
      expiresIn: tokens.expires_in,
      tokenType: tokens.token_type,
      expiresAt: Date.now() + (tokens.expires_in * 1000)
    }
  }

  private isNonRetryableError(error: any): boolean {
    // Don't retry on these errors
    const nonRetryableCodes = [
      'invalid_grant', // Refresh token invalid/expired
      'unauthorized_client',
      'invalid_client'
    ]

    if (error instanceof TokenRefreshError) {
      return (
        nonRetryableCodes.includes(error.errorCode) ||
        error.httpStatus === 400
      )
    }

    return false
  }

  /**
   * Load tokens from secure storage
   */
  private async loadTokens(): Promise<void> {
    try {
      const accessToken = await invoke<string | null>('get_secure_token', {
        service: `lokus-${this.config.provider}`,
        account: 'access_token'
      })

      const refreshToken = await invoke<string | null>('get_secure_token', {
        service: `lokus-${this.config.provider}`,
        account: 'refresh_token'
      })

      const expiresAt = await invoke<string | null>('get_secure_token', {
        service: `lokus-${this.config.provider}`,
        account: 'expires_at'
      })

      if (accessToken && refreshToken && expiresAt) {
        this.accessToken = accessToken
        this.refreshToken = refreshToken
        this.expiresAt = parseInt(expiresAt, 10)
      }
    } catch (error) {
      console.error('Failed to load tokens:', error)
    }
  }

  /**
   * Store tokens in secure storage
   */
  private async storeTokens(tokens: {
    accessToken: string
    refreshToken: string | null
    expiresAt: number
  }): Promise<void> {
    const service = `lokus-${this.config.provider}`

    await invoke('store_secure_token', {
      service,
      account: 'access_token',
      token: tokens.accessToken
    })

    if (tokens.refreshToken) {
      await invoke('store_secure_token', {
        service,
        account: 'refresh_token',
        token: tokens.refreshToken
      })
    }

    await invoke('store_secure_token', {
      service,
      account: 'expires_at',
      token: tokens.expiresAt.toString()
    })
  }

  /**
   * Revoke tokens (sign out)
   */
  async revokeTokens(): Promise<void> {
    if (!this.accessToken) return

    try {
      // Revoke with provider (if supported)
      if (this.config.revocationEndpoint) {
        await fetch(this.config.revocationEndpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({
            token: this.accessToken,
            token_type_hint: 'access_token'
          }).toString()
        })
      }
    } catch (error) {
      console.error('Failed to revoke tokens:', error)
    } finally {
      // Clear local tokens regardless of revocation result
      await this.clearTokens()
    }
  }

  private async clearTokens(): Promise<void> {
    const service = `lokus-${this.config.provider}`

    await invoke('delete_secure_token', { service, account: 'access_token' })
    await invoke('delete_secure_token', { service, account: 'refresh_token' })
    await invoke('delete_secure_token', { service, account: 'expires_at' })

    this.accessToken = null
    this.refreshToken = null
    this.expiresAt = 0
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms))
  }
}

class TokenRefreshError extends Error {
  constructor(
    message: string,
    public httpStatus: number,
    public errorCode: string
  ) {
    super(message)
    this.name = 'TokenRefreshError'
  }
}

// Usage example
const tokenManager = new TokenManager({
  provider: 'gmail',
  clientId: GMAIL_CLIENT_ID,
  tokenEndpoint: 'https://oauth2.googleapis.com/token',
  revocationEndpoint: 'https://oauth2.googleapis.com/revoke'
})

// Get valid token (auto-refreshes if needed)
const accessToken = await tokenManager.getAccessToken()

// Use token
const response = await fetch('https://gmail.googleapis.com/gmail/v1/users/me/messages', {
  headers: {
    'Authorization': `Bearer ${accessToken}`
  }
})
```

---

## Network Security

### HTTPS Enforcement

```typescript
function ensureHttps(url: string): string {
  if (url.startsWith('http://')) {
    return url.replace('http://', 'https://');
  }
  return url;
}

// In configuration
{
  "security": {
    "enforceHttps": true,
    "allowInsecureConnections": false
  }
}
```

---

### CORS Protection

```typescript
const ALLOWED_ORIGINS = [
  'https://api.example.com',
  'https://mail.google.com'
];

function validateOrigin(origin: string): boolean {
  return ALLOWED_ORIGINS.includes(origin);
}
```

---

### Request Validation

```typescript
interface RequestOptions {
  url: string;
  method: string;
  headers?: Record<string, string>;
  body?: string;
}

async function makeSecureRequest(options: RequestOptions) {
  // Validate URL
  if (!isValidUrl(options.url)) {
    throw new Error('Invalid URL');
  }

  // Enforce HTTPS
  if (!options.url.startsWith('https://')) {
    throw new Error('HTTPS required');
  }

  // Validate headers
  validateHeaders(options.headers);

  // Make request
  return await fetch(options.url, {
    method: options.method,
    headers: options.headers,
    body: options.body
  });
}

function validateHeaders(headers?: Record<string, string>) {
  if (!headers) return;

  // Block dangerous headers
  const dangerous = ['Cookie', 'Set-Cookie', 'Authorization'];
  for (const header of Object.keys(headers)) {
    if (dangerous.includes(header)) {
      throw new Error(`Header ${header} not allowed`);
    }
  }
}
```

---

## Content Security

### XSS Prevention

**Input Sanitization:**

```typescript
import DOMPurify from 'dompurify';

function sanitizeHTML(dirty: string): string {
  return DOMPurify.sanitize(dirty, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'u', 'a', 'code', 'pre'],
    ALLOWED_ATTR: ['href', 'class']
  });
}

// Usage
function renderUserContent(content: string) {
  const clean = sanitizeHTML(content);
  return <div dangerouslySetInnerHTML={{ __html: clean }} />;
}
```

**Output Encoding:**

```typescript
function escapeHTML(text: string): string {
  const map: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '/': '&#x2F;'
  };

  return text.replace(/[&<>"'\/]/g, (char) => map[char]);
}
```

---

### Content Security Policy

```html
<meta http-equiv="Content-Security-Policy"
  content="default-src 'self';
           script-src 'self' 'unsafe-inline';
           style-src 'self' 'unsafe-inline';
           img-src 'self' data: https:;
           connect-src 'self' https://api.example.com;">
```

---

### External Content

```json
{
  "security": {
    "allowExternalImages": true,
    "allowExternalLinks": true,
    "blockTrackers": true,
    "validateImageUrls": true
  }
}
```

**Image URL Validation:**

```typescript
function isValidImageUrl(url: string): boolean {
  // Only allow HTTPS
  if (!url.startsWith('https://')) {
    return false;
  }

  // Check allowed domains
  const allowedDomains = ['imgur.com', 'github.com'];
  const domain = new URL(url).hostname;

  return allowedDomains.some(allowed =>
    domain.endsWith(allowed)
  );
}
```

---

## Data Protection

### Encryption at Rest

**Encrypt sensitive settings:**

```rust
use aes_gcm::{Aes256Gcm, Key, Nonce};
use aes_gcm::aead::{Aead, NewAead};

fn encrypt_data(data: &str, key: &[u8]) -> Result<Vec<u8>, String> {
    let cipher = Aes256Gcm::new(Key::from_slice(key));
    let nonce = Nonce::from_slice(b"unique nonce");

    cipher.encrypt(nonce, data.as_bytes())
        .map_err(|e| e.to_string())
}

fn decrypt_data(encrypted: &[u8], key: &[u8]) -> Result<String, String> {
    let cipher = Aes256Gcm::new(Key::from_slice(key));
    let nonce = Nonce::from_slice(b"unique nonce");

    let decrypted = cipher.decrypt(nonce, encrypted)
        .map_err(|e| e.to_string())?;

    String::from_utf8(decrypted)
        .map_err(|e| e.to_string())
}
```

---

### Encryption in Transit

All network communication uses TLS 1.3:

```typescript
const agent = new https.Agent({
  minVersion: 'TLSv1.3',
  maxVersion: 'TLSv1.3',
  rejectUnauthorized: true
});

await fetch(url, { agent });
```

---

## Security Best Practices

### For Users

1. **Keep Lokus Updated** - Install security updates promptly
2. **Use Strong Passwords** - For workspace encryption
3. **Review Plugin Permissions** - Only install trusted plugins
4. **Enable 2FA** - For connected services (Gmail, etc.)
5. **Regular Backups** - Protect against data loss
6. **Secure Workspace** - Use full disk encryption
7. **Log Out** - When using shared computers

---

### For Plugin Developers

1. **Minimal Permissions** - Request only needed permissions
2. **Validate Input** - Sanitize all user input
3. **Secure API Keys** - Use plugin settings storage
4. **HTTPS Only** - Never use HTTP
5. **Error Handling** - Don't expose sensitive info
6. **Regular Updates** - Fix security issues promptly
7. **Code Review** - Review for vulnerabilities

---

### For Self-Hosters

1. **Firewall Rules** - Restrict network access
2. **Regular Updates** - Update OS and dependencies
3. **Access Control** - Limit user permissions
4. **Monitoring** - Log and monitor access
5. **Backup Strategy** - Automated, encrypted backups
6. **Incident Response** - Have a plan
7. **Security Audits** - Regular security reviews

---

## Security Auditing

### Logging

```typescript
class SecurityLogger {
  logAuthAttempt(user: string, success: boolean) {
    console.log(`[AUTH] ${user} - ${success ? 'SUCCESS' : 'FAILURE'}`);
  }

  logFileAccess(plugin: string, path: string, operation: string) {
    console.log(`[FILE] ${plugin} - ${operation} - ${path}`);
  }

  logPermissionDenied(plugin: string, permission: string) {
    console.warn(`[SECURITY] ${plugin} denied ${permission}`);
  }

  logSuspiciousActivity(activity: string, details: any) {
    console.error(`[SECURITY ALERT] ${activity}`, details);
  }
}
```

---

### Monitoring

```typescript
class SecurityMonitor {
  private failedAttempts = new Map<string, number>();

  recordFailedAuth(user: string) {
    const attempts = this.failedAttempts.get(user) || 0;
    this.failedAttempts.set(user, attempts + 1);

    // Alert after 5 failed attempts
    if (attempts >= 5) {
      this.alertSecurityIncident('Brute force attempt', { user });
    }
  }

  alertSecurityIncident(type: string, details: any) {
    // Send alert notification
    console.error(`SECURITY INCIDENT: ${type}`, details);

    // Could integrate with external monitoring
  }
}
```

---

## Vulnerability Reporting

If you discover a security vulnerability:

1. **Do Not** publicly disclose the vulnerability
2. **Email** security@lokus.app with details
3. **Include** steps to reproduce
4. **Wait** for response before disclosure
5. **Receive** credit in security advisories

**Bug Bounty Program:** Coming soon

---

## Security Updates

Stay informed about security updates:

1. **GitHub Security Advisories** - Watch repository
2. **Release Notes** - Read security sections
3. **Newsletter** - Subscribe for alerts
4. **RSS Feed** - Follow security feed

---

## Compliance

### GDPR Compliance

Lokus is designed for GDPR compliance:

- **Data Minimization** - Collect only necessary data
- **Right to Access** - Export all user data
- **Right to Erasure** - Delete user data
- **Data Portability** - Standard file formats
- **Privacy by Design** - Security by default
- **Transparency** - Clear privacy policy

---

### Data Retention

```json
{
  "security": {
    "dataRetention": {
      "logs": 90,
      "cache": 7,
      "backups": 365
    }
  }
}
```

---

## Next Steps

- [Troubleshooting](/advanced/troubleshooting) - Security issues
- [Configuration](/reference/configuration) - Security settings
- [Plugin API](/reference/plugin-api) - Secure plugin development