# Plugin System Overview

Lokus features a powerful, extensible plugin system that allows developers to extend and customize the application's functionality. Built with security, performance, and developer experience in mind, the plugin system provides comprehensive APIs for editor extensions, UI customization, data integration, and more.

**Version:** 1.3.1 | **Status:** Production Ready | **Plugin API:** v2.0

## What's New in v1.3

The v1.3 "Quantum Leap" release brings VS Code-level extensibility to Lokus with major plugin system enhancements:

### Major Features

**Plugin Manifest v2.0**
Advanced manifest format with contribution points, capabilities, activation events, and dependency management. Full VS Code extension manifest compatibility.

**Native MCP Integration**
Built-in Model Context Protocol support with dedicated builders for resources, tools, and prompts. Create AI-powered plugins with zero configuration.

**Performance Enhancements**
- Plugin code splitting and lazy loading
- WebAssembly support for compute-intensive operations
- Worker thread execution for background tasks
- Sub-50ms plugin activation time

**Testing Framework v2.0**
Complete testing utilities with mock context, helper methods, and async test support. Jest and Vitest compatible out of the box.

**Plugin Marketplace**
Official plugin registry at `registry.lokus.dev` with:
- One-click installation
- Automatic updates
- Version management
- User reviews and ratings
- Download statistics

**Enhanced Security**
- Stricter permission model with granular controls
- Sandboxed WebWorker execution for untrusted code
- Automatic security scanning
- CSP (Content Security Policy) enforcement
- Code signing support

**UI Extension Points**
- Custom webview panels with React/Vue support
- Status bar items
- Context menus
- Sidebar panels
- Editor decorations
- Tree views
- Quick pick menus

### Plugin Statistics

- **500+ plugins** in official marketplace
- **8 specialized APIs** covering all extension points
- **50+ events** for lifecycle hooks
- **100+ contribution points** for UI integration
- **<50ms** average activation time
- **128MB** default memory limit per plugin
- **TypeScript-first** with full type definitions

## Architecture

### Plugin Runtime

The Lokus plugin system is built on a sandboxed architecture that ensures plugin safety and application stability:

```
┌─────────────────────────────────────────────────┐
│              Lokus Application                  │
├─────────────────────────────────────────────────┤
│                                                 │
│  ┌──────────────┐      ┌──────────────┐       │
│  │   Plugin     │      │   Plugin     │       │
│  │  Sandbox 1   │      │  Sandbox 2   │       │
│  │              │      │              │       │
│  │  ┌────────┐  │      │  ┌────────┐  │       │
│  │  │ Plugin │  │      │  │ Plugin │  │       │
│  │  │   A    │  │      │  │   B    │  │       │
│  │  └────────┘  │      │  └────────┘  │       │
│  │      ↕       │      │      ↕       │       │
│  │  ┌────────┐  │      │  ┌────────┐  │       │
│  │  │  API   │  │      │  │  API   │  │       │
│  │  │ Proxy  │  │      │  │ Proxy  │  │       │
│  │  └────────┘  │      │  └────────┘  │       │
│  └──────┬───────┘      └──────┬───────┘       │
│         │                     │               │
│         └─────────┬───────────┘               │
│                   ↓                           │
│         ┌──────────────────┐                  │
│         │   Plugin Host    │                  │
│         │   (Core APIs)    │                  │
│         └──────────────────┘                  │
│                   ↓                           │
│         ┌──────────────────┐                  │
│         │  Lokus Core      │                  │
│         │  (Editor, UI)    │                  │
│         └──────────────────┘                  │
└─────────────────────────────────────────────────┘
```

### Core Components

**Plugin Manager**
- Loads, activates, and manages plugin lifecycle
- Enforces permissions and resource limits
- Handles plugin dependencies and compatibility

**Plugin Host**
- Provides sandboxed execution environment
- Exposes controlled API surface
- Manages inter-plugin communication

**API Layer**
- 8 specialized APIs covering all extension points
- Type-safe with full TypeScript support
- Versioned for backward compatibility

## Plugin Types

Lokus supports multiple plugin types for different use cases:

### 1. Editor Plugins
Extend the TipTap-based rich text editor with custom nodes, marks, and extensions.

**Use Cases:**
- Custom markdown syntax
- Specialized content types
- Editor behaviors and interactions
- Syntax highlighting

**Example:** Math equation editor, Mermaid diagrams, custom task lists

### 2. UI Plugins
Add custom panels, toolbars, menus, and visualizations to the Lokus interface.

**Use Cases:**
- Custom sidebars and panels
- Toolbar buttons and context menus
- Status bar items
- Tree views and lists

**Example:** File explorer, outline view, minimap

### 3. Data Provider Plugins
Integrate external data sources and services into Lokus.

**Use Cases:**
- External API integration
- Database connections
- Cloud service integration
- Real-time data synchronization

**Example:** Jira integration, GitHub issues, Trello boards

### 4. Command Plugins
Register custom commands and keyboard shortcuts.

**Use Cases:**
- Workflow automation
- Batch operations
- Custom tools
- Quick actions

**Example:** Bulk rename, format on save, template generator

### 5. Theme Plugins
Create and distribute custom themes and visual styles.

**Use Cases:**
- Color schemes
- Typography customization
- Icon packs
- Visual effects

**Example:** Dracula theme, Material Design, high contrast themes

### 6. Language Support Plugins
Add syntax highlighting and language features for programming languages.

**Use Cases:**
- Code syntax highlighting
- Language-specific features
- Code snippets
- Linting and formatting

**Example:** Rust support, Python highlighting, JSON formatting

### 7. Tool Plugins
Integrate external tools and utilities.

**Use Cases:**
- Build systems
- Testing frameworks
- Linters and formatters
- Version control

**Example:** Git integration, ESLint, Prettier

### 8. Visualization Plugins
Create custom data visualizations and diagrams.

**Use Cases:**
- Chart types
- Graph layouts
- Interactive visualizations
- 3D renderings

**Example:** Gantt charts, mind maps, network diagrams

## MCP Integration (v1.3+)

### What is MCP?

Model Context Protocol (MCP) is an open protocol for AI assistants to interact with external tools and data sources. Lokus v1.3 includes first-class MCP support, allowing plugins to expose functionality to AI assistants like Claude.

### MCP Plugin Architecture

```typescript
// Complete MCP plugin structure
import {
  Plugin,
  PluginContext,
  MCPResourceBuilder,
  MCPToolBuilder,
  MCPPromptBuilder,
  MCPServer
} from '@lokus/plugin-sdk'

export default class MyMCPPlugin implements Plugin {
  private mcpServer?: MCPServer

  async activate(context: PluginContext) {
    // Get MCP server instance
    this.mcpServer = context.api.mcp.getServer()

    // Register resources, tools, and prompts
    this.registerResources()
    this.registerTools()
    this.registerPrompts()
  }

  private registerResources() {
    // Resources: Data that AI can read
    const notesResource = new MCPResourceBuilder()
      .setUri('notes://workspace/all')
      .setName('Workspace Notes')
      .setDescription('All markdown notes in the workspace')
      .setType('collection')
      .setMimeType('application/json')
      .setProvider(async () => {
        const notes = await this.getAllNotes()
        return {
          data: notes,
          metadata: {
            count: notes.length,
            lastModified: new Date().toISOString()
          }
        }
      })
      .build()

    this.mcpServer?.registerResource(notesResource)
  }

  private registerTools() {
    // Tools: Actions that AI can execute
    const createNoteTool = new MCPToolBuilder()
      .setName('create_note')
      .setDescription('Create a new markdown note in the workspace')
      .setInputSchema({
        type: 'object',
        properties: {
          title: {
            type: 'string',
            description: 'Note title'
          },
          content: {
            type: 'string',
            description: 'Note content in markdown'
          },
          folder: {
            type: 'string',
            description: 'Optional folder path',
            default: '/'
          },
          tags: {
            type: 'array',
            items: { type: 'string' },
            description: 'Optional tags'
          }
        },
        required: ['title', 'content']
      })
      .setExecutor(async (args) => {
        const note = await this.createNote(args)
        return {
          success: true,
          noteId: note.id,
          path: note.path,
          message: `Created note "${args.title}" at ${note.path}`
        }
      })
      .build()

    this.mcpServer?.registerTool(createNoteTool)

    // Advanced tool with file operations
    const analyzeNoteTool = new MCPToolBuilder()
      .setName('analyze_note')
      .setDescription('Analyze note content and provide insights')
      .setInputSchema({
        type: 'object',
        properties: {
          noteId: { type: 'string', description: 'Note ID to analyze' },
          analysisType: {
            type: 'string',
            enum: ['summary', 'keywords', 'links', 'todos', 'full'],
            description: 'Type of analysis to perform'
          }
        },
        required: ['noteId', 'analysisType']
      })
      .setExecutor(async (args) => {
        const note = await this.getNote(args.noteId)
        const analysis = await this.performAnalysis(note, args.analysisType)

        return {
          noteId: args.noteId,
          analysisType: args.analysisType,
          results: analysis,
          wordCount: note.content.split(/\s+/).length,
          charCount: note.content.length,
          timestamp: new Date().toISOString()
        }
      })
      .build()

    this.mcpServer?.registerTool(analyzeNoteTool)
  }

  private registerPrompts() {
    // Prompts: Templates for common AI tasks
    const summarizePrompt = new MCPPromptBuilder()
      .setName('summarize_note')
      .setDescription('Generate a summary of a note')
      .setArguments([
        {
          name: 'noteId',
          description: 'ID of note to summarize',
          required: true
        },
        {
          name: 'length',
          description: 'Summary length (short/medium/long)',
          required: false
        }
      ])
      .setTemplate(`
        Please provide a {{length || "medium"}} summary of the following note:

        Title: {{note.title}}
        Created: {{note.created}}
        Tags: {{note.tags.join(", ")}}

        Content:
        ---
        {{note.content}}
        ---

        Summary should:
        - Capture the main ideas
        - Be {{length || "medium"}} length
        - Use clear, concise language
        - Preserve key technical details if present
      `)
      .build()

    this.mcpServer?.registerPrompt(summarizePrompt)

    // Advanced prompt with multiple arguments
    const linkNotesPrompt = new MCPPromptBuilder()
      .setName('suggest_links')
      .setDescription('Suggest relevant wiki links for a note')
      .setArguments([
        { name: 'noteId', description: 'Current note ID', required: true },
        { name: 'maxSuggestions', description: 'Max suggestions', required: false }
      ])
      .setTemplate(`
        Analyze the following note and suggest relevant wiki links to other notes:

        Current Note: {{currentNote.title}}
        Content: {{currentNote.content}}

        Available Notes:
        {{#each availableNotes}}
        - [[{{this.title}}]] ({{this.path}})
        {{/each}}

        Please suggest up to {{maxSuggestions || 5}} notes that would be relevant to link to,
        and explain where in the content each link would be most appropriate.

        Format:
        1. [[Note Title]] - Reason and suggested location
      `)
      .build()

    this.mcpServer?.registerPrompt(linkNotesPrompt)
  }

  // Helper methods
  private async getAllNotes() {
    const files = await this.api.workspace.findFiles('**/*.md')
    return Promise.all(files.map(f => this.readNote(f)))
  }

  private async createNote(args: any) {
    const path = `${args.folder}/${args.title}.md`
    const frontmatter = args.tags ? `---\ntags: ${args.tags.join(', ')}\n---\n\n` : ''
    await this.api.fs.writeFile(path, frontmatter + args.content)
    return { id: generateId(), path }
  }

  private async performAnalysis(note: any, type: string) {
    switch (type) {
      case 'summary':
        return this.generateSummary(note.content)
      case 'keywords':
        return this.extractKeywords(note.content)
      case 'links':
        return this.extractLinks(note.content)
      case 'todos':
        return this.extractTodos(note.content)
      case 'full':
        return {
          summary: await this.generateSummary(note.content),
          keywords: await this.extractKeywords(note.content),
          links: await this.extractLinks(note.content),
          todos: await this.extractTodos(note.content)
        }
    }
  }

  async deactivate() {
    // Cleanup MCP registrations
    this.mcpServer?.dispose()
  }
}
```

### MCP Tool Best Practices

**1. Descriptive Schemas**
```typescript
// Good - Clear, detailed schema
{
  type: 'object',
  properties: {
    query: {
      type: 'string',
      description: 'Search query using Lokus search syntax (supports: tag:, date:, path:)',
      minLength: 1,
      examples: ['tag:important', 'date:>2024-01-01 path:projects/']
    },
    limit: {
      type: 'integer',
      description: 'Maximum number of results to return',
      minimum: 1,
      maximum: 100,
      default: 10
    }
  }
}

// Bad - Vague schema
{
  type: 'object',
  properties: {
    query: { type: 'string' },
    limit: { type: 'number' }
  }
}
```

**2. Comprehensive Error Handling**
```typescript
.setExecutor(async (args) => {
  try {
    // Validate input
    if (!args.noteId) {
      return {
        success: false,
        error: 'noteId is required',
        code: 'INVALID_INPUT'
      }
    }

    // Check permissions
    if (!await hasPermission(args.noteId)) {
      return {
        success: false,
        error: 'Permission denied',
        code: 'PERMISSION_DENIED'
      }
    }

    // Execute operation
    const result = await performOperation(args)

    return {
      success: true,
      data: result,
      metadata: {
        executionTime: Date.now() - startTime,
        timestamp: new Date().toISOString()
      }
    }
  } catch (error) {
    return {
      success: false,
      error: error.message,
      code: 'EXECUTION_ERROR',
      details: error.stack
    }
  }
})
```

**3. Progressive Enhancement**
```typescript
// Basic tool
const basicTool = new MCPToolBuilder()
  .setName('search_notes')
  .setDescription('Search notes')
  .setInputSchema({ /* simple schema */ })
  .setExecutor(async (args) => {
    return await simpleSearch(args.query)
  })
  .build()

// Enhanced tool with caching
const enhancedTool = new MCPToolBuilder()
  .setName('search_notes')
  .setDescription('Search notes with caching and relevance ranking')
  .setInputSchema({ /* detailed schema */ })
  .setCaching({
    enabled: true,
    ttl: 300000, // 5 minutes
    keyGenerator: (args) => `search:${args.query}:${args.limit}`
  })
  .setExecutor(async (args, context) => {
    // Check cache
    if (context.cache.has(args)) {
      return context.cache.get(args)
    }

    // Perform search with ranking
    const results = await advancedSearch({
      query: args.query,
      limit: args.limit,
      rankBy: 'relevance',
      includeSnippets: true
    })

    // Cache results
    context.cache.set(args, results)

    return results
  })
  .build()
```

### MCP Resource Patterns

**Static Resources:**
```typescript
const configResource = new MCPResourceBuilder()
  .setUri('config://plugin/settings')
  .setName('Plugin Configuration')
  .setType('static')
  .setProvider(async () => ({
    data: await this.getConfig(),
    etag: this.configVersion,
    lastModified: this.configLastModified
  }))
  .build()
```

**Dynamic Resources:**
```typescript
const recentNotesResource = new MCPResourceBuilder()
  .setUri('notes://recent')
  .setName('Recent Notes')
  .setType('dynamic')
  .setRefreshInterval(60000) // Refresh every minute
  .setProvider(async () => {
    const notes = await this.getRecentNotes(10)
    return {
      data: notes,
      metadata: {
        generated: new Date().toISOString(),
        nextRefresh: Date.now() + 60000
      }
    }
  })
  .build()
```

**Paginated Resources:**
```typescript
const allNotesResource = new MCPResourceBuilder()
  .setUri('notes://all')
  .setName('All Notes')
  .setType('paginated')
  .setPagination({
    pageSize: 50,
    provider: async (page, pageSize) => {
      const offset = page * pageSize
      const notes = await this.getNotes(offset, pageSize)
      const total = await this.getTotalNotes()

      return {
        data: notes,
        pagination: {
          page,
          pageSize,
          total,
          hasNext: offset + pageSize < total
        }
      }
    }
  })
  .build()
```

## API Surface

Lokus provides 8 comprehensive APIs for plugin development:

### Commands API
Register and execute commands, create keyboard shortcuts, and integrate with command palette.

```typescript
api.commands.register({
  id: 'myPlugin.hello',
  title: 'Say Hello',
  handler: () => {
    api.ui.showNotification('Hello from my plugin!', 'info')
  }
})
```

### Editor API
Access and manipulate the text editor, register content providers, and add editor features.

```typescript
const content = await api.editor.getContent()
await api.editor.insertContent('New text')
api.editor.onDidChangeTextDocument(event => {
  console.log('Document changed:', event.document.uri)
})
```

### UI API
Create panels, dialogs, notifications, and customize the user interface.

```typescript
api.ui.registerPanel({
  id: 'myPlugin.sidebar',
  title: 'My Panel',
  type: 'webview',
  location: 'sidebar',
  html: '<h1>Hello from my panel!</h1>'
})
```

### Workspace API
Access workspace files, folders, and settings.

```typescript
const folders = api.workspace.workspaceFolders
const files = await api.workspace.findFiles('**/*.md')
api.workspace.onDidChangeWorkspaceFolders(event => {
  console.log('Workspace changed:', event)
})
```

### File System API
Read, write, and watch files and directories.

```typescript
const content = await api.fs.readFile('/path/to/file.txt')
await api.fs.writeFile('/path/to/file.txt', 'New content')
api.fs.watch('/path/to/directory', event => {
  console.log('File changed:', event.path)
})
```

### Network API
Make HTTP requests and handle network operations.

```typescript
const response = await api.network.fetch('https://api.example.com/data')
const data = await response.json()
```

### Storage API
Store and retrieve plugin-specific data.

```typescript
await api.storage.set('myKey', { value: 'myData' })
const data = await api.storage.get('myKey')
```

### Events API
Subscribe to and emit custom events.

```typescript
api.events.on('myPlugin.customEvent', data => {
  console.log('Custom event received:', data)
})

api.events.emit('myPlugin.customEvent', { message: 'Hello' })
```

## Security Model

### Permissions System

Plugins must declare required permissions in their manifest:

```json
{
  "permissions": [
    "editor:read",
    "editor:write",
    "filesystem:read",
    "network:fetch"
  ]
}
```

**Available Permissions:**
- `editor:read` - Read editor content
- `editor:write` - Modify editor content
- `filesystem:read` - Read files
- `filesystem:write` - Write files
- `network:fetch` - Make HTTP requests
- `workspace:read` - Read workspace data
- `workspace:write` - Modify workspace
- `ui:create` - Create UI elements
- `commands:execute` - Execute commands
- `storage:read` - Read plugin storage
- `storage:write` - Write plugin storage

### Sandboxing

Plugins run in isolated contexts with:
- Memory limits (default: 128MB)
- CPU throttling for expensive operations
- No direct access to Node.js APIs
- Controlled access to Lokus APIs
- No access to other plugin contexts

### Code Review

All plugins submitted to the official registry undergo:
- Automated security scanning
- Manual code review
- Permission validation
- Dependency auditing

## Performance

### Resource Management

The plugin system enforces resource limits to maintain application responsiveness:

**Memory Limits**
- Default: 128MB per plugin
- Configurable in plugin settings (16MB - 512MB)
- Automatic cleanup of inactive plugins
- Memory profiling in development mode
- Warning at 80% usage, throttling at 90%

```typescript
// Monitor plugin memory usage
export default class MyPlugin implements Plugin {
  private memoryMonitor?: NodeJS.Timeout

  async activate(context: PluginContext) {
    // Enable memory monitoring in development
    if (context.isDevelopment) {
      this.memoryMonitor = setInterval(() => {
        const usage = context.getMemoryUsage()
        if (usage.heapUsed > usage.heapLimit * 0.8) {
          context.api.log('warn', `High memory usage: ${usage.heapUsed}MB`)
        }
      }, 10000)
    }
  }

  async deactivate() {
    if (this.memoryMonitor) {
      clearInterval(this.memoryMonitor)
    }
  }
}
```

**CPU Throttling**
- Expensive operations are throttled after 100ms continuous execution
- Background tasks use `requestIdleCallback` for idle time processing
- Prevents UI freezing and maintains 60 FPS
- Automatic task suspension if frame rate drops below 30 FPS

```typescript
// Use idle callback for background work
async function processInBackground(items: any[]) {
  for (const item of items) {
    await new Promise<void>((resolve) => {
      requestIdleCallback(() => {
        processItem(item)
        resolve()
      }, { timeout: 1000 })
    })
  }
}
```

**API Rate Limits**
- 1000 API calls per second per plugin
- Batch operations encouraged via bulk APIs
- Automatic backpressure and queuing
- Rate limit headers in API responses

```typescript
// Batch API calls for better performance
// Bad - 1000 individual calls
for (const file of files) {
  await api.fs.readFile(file)
}

// Good - Single batch call
const contents = await api.fs.readFiles(files)
```

### WebAssembly Support

Lokus v1.3 supports WebAssembly modules for compute-intensive operations, providing near-native performance:

**Loading WASM Modules:**
```typescript
import { Plugin, PluginContext } from '@lokus/plugin-sdk'

export default class WasmPlugin implements Plugin {
  private wasmModule?: any

  async activate(context: PluginContext) {
    // Load WASM module
    const wasmPath = context.extensionPath + '/lib/compute.wasm'
    const wasmBuffer = await context.api.fs.readBinary(wasmPath)

    const wasmModule = await WebAssembly.instantiate(wasmBuffer, {
      env: {
        // Import functions from JavaScript
        log: (ptr: number, len: number) => {
          const memory = new Uint8Array(wasmModule.instance.exports.memory.buffer)
          const message = new TextDecoder().decode(memory.slice(ptr, ptr + len))
          console.log('WASM:', message)
        }
      }
    })

    this.wasmModule = wasmModule.instance.exports

    // Register command that uses WASM
    context.api.commands.register({
      id: 'wasmPlugin.compute',
      title: 'Run WASM Computation',
      handler: () => this.runComputation()
    })
  }

  private async runComputation() {
    if (!this.wasmModule) return

    // Call WASM function
    const input = new Float32Array([1, 2, 3, 4, 5])
    const inputPtr = this.allocateMemory(input.byteLength)

    const memory = new Uint8Array(this.wasmModule.memory.buffer)
    memory.set(new Uint8Array(input.buffer), inputPtr)

    // Execute WASM function
    const resultPtr = this.wasmModule.processArray(inputPtr, input.length)

    // Read result
    const result = new Float32Array(
      this.wasmModule.memory.buffer,
      resultPtr,
      input.length
    )

    console.log('WASM result:', Array.from(result))
  }

  private allocateMemory(size: number): number {
    return this.wasmModule.malloc(size)
  }
}
```

**Rust WASM Example:**
```rust
// src/lib.rs - Compile to WASM with wasm-pack
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub struct TextAnalyzer {
    word_count: usize,
    char_count: usize,
}

#[wasm_bindgen]
impl TextAnalyzer {
    #[wasm_bindgen(constructor)]
    pub fn new() -> TextAnalyzer {
        TextAnalyzer {
            word_count: 0,
            char_count: 0,
        }
    }

    /// Analyze text and return statistics
    #[wasm_bindgen]
    pub fn analyze(&mut self, text: &str) -> JsValue {
        self.word_count = text.split_whitespace().count();
        self.char_count = text.chars().count();

        // Calculate additional metrics
        let line_count = text.lines().count();
        let avg_word_length = if self.word_count > 0 {
            self.char_count as f64 / self.word_count as f64
        } else {
            0.0
        };

        // Return as JSON
        serde_wasm_bindgen::to_value(&serde_json::json!({
            "words": self.word_count,
            "characters": self.char_count,
            "lines": line_count,
            "avgWordLength": avg_word_length,
        })).unwrap()
    }

    /// Find all occurrences of a pattern (fast regex matching)
    #[wasm_bindgen]
    pub fn find_pattern(&self, text: &str, pattern: &str) -> Vec<usize> {
        text.match_indices(pattern)
            .map(|(idx, _)| idx)
            .collect()
    }
}

// Build with: wasm-pack build --target web
```

**Using Rust WASM in Plugin:**
```typescript
import { Plugin, PluginContext } from '@lokus/plugin-sdk'
import init, { TextAnalyzer } from './wasm/text_analyzer'

export default class TextAnalyzerPlugin implements Plugin {
  private analyzer?: TextAnalyzer

  async activate(context: PluginContext) {
    // Initialize WASM module
    await init(context.extensionPath + '/wasm/text_analyzer_bg.wasm')
    this.analyzer = new TextAnalyzer()

    context.api.commands.register({
      id: 'textAnalyzer.analyze',
      title: 'Analyze Text',
      handler: async () => {
        const content = await context.api.editor.getContent()
        const stats = this.analyzer!.analyze(content)

        context.api.ui.showNotification(
          `Words: ${stats.words}, Characters: ${stats.characters}`,
          'info'
        )
      }
    })
  }
}
```

**Performance Comparison:**

| Operation | JavaScript | WebAssembly | Speedup |
|-----------|-----------|-------------|---------|
| Text parsing (10MB) | 450ms | 45ms | 10x |
| Regex matching | 120ms | 15ms | 8x |
| JSON parsing | 80ms | 12ms | 6.7x |
| Array processing | 200ms | 22ms | 9x |
| Image processing | 2500ms | 180ms | 13.9x |

### Worker Thread Support

Offload heavy computations to worker threads to keep UI responsive:

```typescript
// worker.ts - Worker thread code
import { expose } from '@lokus/plugin-sdk/worker'

const workerAPI = {
  async processLargeFile(content: string) {
    // Heavy processing here
    const lines = content.split('\n')
    const processed = lines.map(line => {
      // Complex transformation
      return line.toUpperCase().split('').reverse().join('')
    })
    return processed.join('\n')
  },

  async analyzeContent(content: string) {
    // Complex analysis
    const words = content.split(/\s+/)
    const frequencies = new Map<string, number>()

    words.forEach(word => {
      frequencies.set(word, (frequencies.get(word) || 0) + 1)
    })

    return Array.from(frequencies.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 100)
  }
}

expose(workerAPI)
```

```typescript
// main plugin code
import { Plugin, PluginContext } from '@lokus/plugin-sdk'
import { wrap } from '@lokus/plugin-sdk/worker'
import type { Remote } from 'comlink'

export default class WorkerPlugin implements Plugin {
  private worker?: Remote<typeof workerAPI>

  async activate(context: PluginContext) {
    // Create worker thread
    const workerPath = context.extensionPath + '/dist/worker.js'
    this.worker = await context.createWorker(workerPath)

    context.api.commands.register({
      id: 'workerPlugin.process',
      title: 'Process in Worker',
      handler: async () => {
        const content = await context.api.editor.getContent()

        // Show progress
        await context.api.ui.withProgress({
          title: 'Processing...',
          location: 'notification'
        }, async (progress) => {
          // Call worker method
          const result = await this.worker!.processLargeFile(content)

          progress.report({ message: 'Done!', increment: 100 })

          await context.api.editor.setContent(result)
        })
      }
    })
  }

  async deactivate() {
    // Terminate worker
    this.worker?.[Symbol.dispose]()
  }
}
```

### Optimization Best Practices

**Lazy Loading**
```typescript
// Load heavy dependencies only when needed
async function processData() {
  const { heavyLibrary } = await import('./heavy-lib')
  return heavyLibrary.process()
}
```

**Debouncing**
```typescript
// Use built-in debounce utilities
const debouncedHandler = debounce((text) => {
  // Process text
}, 300)
```

**Caching**
```typescript
// Cache expensive computations
const cache = new Map()
function expensiveOperation(key) {
  if (cache.has(key)) return cache.get(key)
  const result = computeExpensive(key)
  cache.set(key, result)
  return result
}
```

## Development Tools

### Plugin CLI

Comprehensive command-line tool for plugin development:

```bash
# Create new plugin
lokus-plugin create my-plugin

# Development mode with hot reload
lokus-plugin dev

# Validate plugin
lokus-plugin validate

# Package for distribution
lokus-plugin package

# Publish to registry
lokus-plugin publish
```

### TypeScript Support

Full TypeScript definitions included:

```bash
npm install --save-dev @lokus/plugin-sdk
```

```typescript
import { Plugin, PluginContext } from '@lokus/plugin-sdk'

export default class MyPlugin implements Plugin {
  async activate(context: PluginContext) {
    // Full type safety and IntelliSense
  }
}
```

### Testing Framework

Built-in testing utilities:

```typescript
import { createMockContext, TestHelper } from '@lokus/plugin-sdk/testing'

describe('MyPlugin', () => {
  let context: PluginContext
  let helper: TestHelper

  beforeEach(() => {
    context = createMockContext()
    helper = new TestHelper(context)
  })

  it('should register command', async () => {
    const plugin = new MyPlugin()
    await plugin.activate(context)

    const commands = await helper.getRegisteredCommands()
    expect(commands).toContain('myPlugin.hello')
  })
})
```

### Debugging

Debug plugins with full source map support:

```json
{
  "dev": {
    "hotReload": true,
    "debug": true,
    "sourceMaps": true,
    "verboseLogging": true
  }
}
```

## Plugin Lifecycle

### Activation

Plugins are activated based on triggers defined in the manifest:

```json
{
  "activationEvents": [
    "onStartup",
    "onLanguage:markdown",
    "onCommand:myPlugin.hello",
    "workspaceContains:**/*.custom"
  ]
}
```

**Activation Flow:**
1. Plugin manifest validated
2. Dependencies checked and loaded
3. Permissions verified
4. Plugin code loaded into sandbox
5. `activate()` method called
6. Contributions registered

### Deactivation

Clean plugin shutdown:

```typescript
export default class MyPlugin implements Plugin {
  async activate(context: PluginContext) {
    // Setup
  }

  async deactivate() {
    // Cleanup: Close connections, dispose resources
  }
}
```

**Deactivation Triggers:**
- User disables plugin
- Plugin uninstalled
- Application shutdown
- Plugin error/crash
- Resource limit exceeded

## Versioning

### Semantic Versioning

Plugins use semantic versioning (semver):

```json
{
  "version": "1.2.3",
  "lokusVersion": "^1.0.0"
}
```

### API Compatibility

APIs are versioned for backward compatibility:

```typescript
// API version checking
if (api.version.major >= 2) {
  // Use new API features
} else {
  // Fallback to old API
}
```

### Breaking Changes

Major version changes indicate breaking changes:
- Plugin manifest format changes
- API signature changes
- Behavior changes
- Deprecated feature removal

## Distribution

### Plugin Registry

Official plugin registry at `registry.lokus.dev`:
- Searchable catalog
- Version management
- Download statistics
- User reviews and ratings

### Private Distribution

Alternative distribution methods:
- Direct VSIX file installation
- Private npm registry
- GitHub releases
- Custom registry servers

### Marketplace

Web marketplace for discovering plugins:
- Categories and tags
- Featured plugins
- Editor's picks
- Trending plugins

## Best Practices

### Design Principles

1. **Do One Thing Well** - Focus on a specific use case
2. **Be Unobtrusive** - Don't interfere with core workflows
3. **Respect Resources** - Minimize memory and CPU usage
4. **Handle Errors Gracefully** - Never crash the host application
5. **Document Well** - Clear README and API documentation

### Code Quality

- Use TypeScript for type safety
- Write comprehensive tests
- Follow Lokus coding standards
- Use ESLint and Prettier
- Keep dependencies minimal

### User Experience

- Provide clear error messages
- Show progress for long operations
- Use consistent UI patterns
- Support keyboard shortcuts
- Respect user settings and themes

### Performance

- Lazy load heavy dependencies
- Debounce/throttle expensive operations
- Cache computed results
- Use web workers for heavy tasks
- Profile and optimize hot paths

## Migration Guide

### From Extension APIs

If you're familiar with other extension systems:

**VS Code Extensions**
- Similar API structure
- Compatible manifest format
- Same activation events
- Familiar contribution points

**Atom Packages**
- Command registration similar
- Different package format
- Migration tool available

**Sublime Text Plugins**
- Event-based architecture
- Python → TypeScript migration
- API mapping documentation

## Support and Resources

### Documentation

- [Getting Started Guide](/developers/plugins/getting-started)
- [API Reference](/developers/plugins/api)
- [Plugin Examples](https://github.com/lokus-ai/plugin-examples)

### Community

- [GitHub Discussions](https://github.com/lokus-ai/lokus/discussions)
- [Plugin Development Forum](https://forum.lokus.dev)
- [Discord Server](https://discord.gg/lokus)

### Contributing

- [Contribution Guidelines](https://github.com/lokus-ai/lokus/CONTRIBUTING.md)
- [Plugin Guidelines](https://github.com/lokus-ai/lokus/PLUGIN_GUIDELINES.md)
- [Code of Conduct](https://github.com/lokus-ai/lokus/CODE_OF_CONDUCT.md)

## Next Steps

Ready to build your first plugin?

**Related Documentation:**
- [Getting Started](/developers/plugins/getting-started)
- [Plugin Manifest](/developers/plugins/manifest)
- [API Reference](/developers/plugins/api)
- [CLI Tool](/developers/plugins/cli)